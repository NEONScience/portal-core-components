"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BasicAvailabilityGrid;
var _lodash = require("lodash");
var _d3Selection = require("d3-selection");
var _d3Drag = require("d3-drag");
var _uniqueId = _interopRequireDefault(require("lodash/uniqueId"));
var _Theme = _interopRequireWildcard(require("../Theme/Theme"));
var _AvailabilitySvgComponents = require("./AvailabilitySvgComponents");
var _AvailabilityUtils = require("./AvailabilityUtils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * BasicAvailabilityGrid generator function
 * @param {object} config - all arguments, see below:
 * * @param {object} svgRef Pointer to an <svg> element generated by useRef()
 * * @param {object} data View object containing name, rows, and getLabel functions
 * * @param {object} sites
 * * * @param {array} value Array of site code strings to show as selected
 * * * @param {array} validValues Array of site code strings known to have some data
 *         in the data set. This is only superfluous when the view is "site". Otherwise,
 *         for example, clicking the summary view row has no way of knowing the specific
 *         sites that actually apply when "selecting all" for this particular product
 * * @param {function} setSitesValue Setter from useState hook defined in
 *       parent to set state for sites
 * * @param {object} dateRange
 * * * @param {array} value Array of exactly two "YYYY-MM" strings
 * * * @param {array} validValues Array of exactly two "YYYY-MM" strings
 *       representing the limits of available / selectable data for the product
 * * @param {function} setDateRangeValue Setter from useState hook defined in
 *       parent to set state for dateRange
 * * @param {boolean} selectionEnabled Whether to hook up interactions to allow
 *       user selection of sites
 */
function BasicAvailabilityGrid(config) {
  /**
     Extract Config
  */
  const {
    svgRef,
    data,
    sites = {
      value: [],
      validValues: []
    },
    allSites = {},
    sortedSites = [],
    setSitesValue = null,
    dateRange = {
      value: [],
      validValues: [_AvailabilityUtils.TIME.MIN_YEAR_MONTH, _AvailabilityUtils.TIME.MAX_YEAR_MONTH]
    },
    setDateRangeValue = () => {},
    selectionEnabled = true
  } = config;

  /**
     Sanity Check: svgRef must be a valid ref
  */
  if (!svgRef || !svgRef.current) {
    return null;
  }

  /**
     Sanity Check: data must exist and have rows
  */
  if (!data || !data.rows) {
    return null;
  }

  /**
     Setup: Inputs and Base Values
  */
  const svg = (0, _d3Selection.select)(svgRef.current);
  if (svg.attr('id') === null) {
    svg.attr('id', "availability-".concat((0, _uniqueId.default)()));
  }
  const svgId = svg.attr('id');
  const svgWidth = parseFloat(svg.attr('width'));
  const svgHeight = parseFloat(svg.attr('height'));
  const rowKeys = sortedSites.length ? sortedSites : Object.keys(data.rows).sort().reverse();
  const rowCount = rowKeys.length;

  /**
     Sanity Check: svg must have discrete numeric dimensions
  */
  if (Number.isNaN(svgWidth) || Number.isNaN(svgHeight)) {
    return null;
  }

  /**
     Setup: Static site/domain/state data
     Create mappings of all sites for given state or domain
     to aid in showing partial vs. full selections
  */
  const siteViewMaps = {
    domains: {},
    states: {}
  };
  Object.keys(allSites).forEach(site => {
    const domain = allSites[site].domainCode;
    if (!siteViewMaps.domains[domain]) {
      siteViewMaps.domains[domain] = [];
    }
    siteViewMaps.domains[domain].push(site);
    const state = allSites[site].stateCode;
    if (!siteViewMaps.states[state]) {
      siteViewMaps.states[state] = [];
    }
    siteViewMaps.states[state].push(site);
  });

  /**
     Setup: Interaction state vars (local vars is all we need here)
  */
  let rowHoverKey = null;
  let draggingCells = false;

  /* eslint-disable no-unused-vars */
  let dateRangeHoverKey = null;
  const draggingDateRange = [{
    dragging: false,
    centerDragX: 0
  }, {
    dragging: false,
    centerDragX: 0
  }];
  /* eslint-enable no-unused-vars */

  /**
     Functions to filter TIME.YEAR_MONTHS and TIME.YEARS to only what's in view
     given the current dragOffset and the clip width. We use this to
     feed data to d3 selections in order to only draw what will actually
     be visible.
  */
  const getLabelWidth = () => {
    if (data.view === 'products') return _AvailabilityUtils.SVG.PRODUCT_LABEL_WIDTH;
    return data.view === 'ungrouped' ? _AvailabilityUtils.SVG.UNGROUPED_LABEL_WIDTH : _AvailabilityUtils.SVG.GROUPED_LABEL_WIDTH;
  };
  const getMinTimeOffset = () => 0 - (_AvailabilityUtils.SVG.ABS_MAX_DATA_WIDTH - (svgWidth - getLabelWidth()));
  const getYearStartX = year => {
    const intYear = parseInt(year, 10);
    return getLabelWidth() + _AvailabilityUtils.SVG.END_PADDING + _AvailabilityUtils.TIME.YEARS.indexOf(intYear) * (_AvailabilityUtils.SVG.YEAR_WIDTH + _AvailabilityUtils.SVG.YEAR_PADDING);
  };
  const getYearCenterX = year => getYearStartX(year) + _AvailabilityUtils.SVG.YEAR_WIDTH / 2;
  const getYearMonthStartX = yearMonth => {
    const year = parseInt(yearMonth.substr(0, 4), 10);
    const month = parseInt(yearMonth.substr(5, 2), 10);
    const yearIdx = _AvailabilityUtils.TIME.YEARS.indexOf(year);
    if (yearIdx === -1 || month < 1 || month > 12) {
      return 0;
    }
    return getYearStartX(year) + (month - 1) * _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH;
  };
  const getYearMonthsInView = (totalSvgWidth, dragOffset) => _AvailabilityUtils.TIME.YEAR_MONTHS.filter(yearMonth => {
    const tX = getYearMonthStartX(yearMonth) + dragOffset;
    const margin = _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH * 4;
    const lower = Math.max(0, getLabelWidth() - margin);
    const upper = totalSvgWidth + margin;
    return tX > lower && tX + _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH < upper;
  });
  const getYearsInView = (totalSvgWidth, dragOffset) => _AvailabilityUtils.TIME.YEARS.filter(year => {
    const tX = getYearStartX(year) + dragOffset;
    const lower = -2 * _AvailabilityUtils.SVG.YEAR_WIDTH;
    const upper = totalSvgWidth - getLabelWidth() + 2 * _AvailabilityUtils.SVG.YEAR_WIDTH;
    return tX > lower && tX + _AvailabilityUtils.SVG.YEAR_WIDTH < upper;
  });

  /**
     Function to generate the "initial" time offset for first load. By default we may extend the
     viewable time range well beyond available data (e.g. if there is no data this year the chart
     should still show dates for this year so it's not ambiguous). This function aims to generate
     an ideal time offset that will put the latest month with availability in view and close to the
     right edge, but also keeping full year labels in view (why we target 8 months of the latest
     year... the right number of months so the year label is not cut off even if the year is empty)
  */
  const getInitialTimeOffset = () => {
    const minTimeOffset = getMinTimeOffset();
    if (!data || !data.rows) {
      return minTimeOffset;
    }
    let availableMonths = [];
    if (data.rows.summary) {
      availableMonths = Object.keys(data.rows.summary);
    } else {
      const availableMonthsSet = new Set();
      Object.keys(data.rows).forEach(rowKey => {
        Object.keys(data.rows[rowKey]).forEach(availableMonthsSet.add, availableMonthsSet);
      });
      availableMonths = Array.from(availableMonthsSet.values());
    }
    if (!availableMonths.length) {
      return minTimeOffset;
    }
    availableMonths.sort();
    const latestAvailableYearMonth = availableMonths[availableMonths.length - 1];
    const latestAvailableYearInt = parseInt(latestAvailableYearMonth.substr(0, 4), 10);
    const latestAvailableMonthInt = parseInt(latestAvailableYearMonth.substr(5, 2), 10);
    const finalMonth = latestAvailableMonthInt <= 6 ? "".concat(latestAvailableYearInt, "-08") : "".concat(latestAvailableYearInt + 1, "-08");
    return Math.max(0 - getYearMonthStartX(finalMonth) - _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH + svgWidth, minTimeOffset);
  };

  /**
     Functions to get a translate() string for a data row by index
     in the sorted rowKeys array
  */
  const getRowY = idx => _AvailabilityUtils.SVG.CELL_PADDING + (rowCount - idx) * (_AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING);
  const getRowTranslation = (d, idx) => "translate(0,".concat(getRowY(idx), ")");

  /**
     Main SVG Structure
     (Layered groups, clip definition, etc.)
  */
  svg.selectAll('*').remove();
  const clipWidth = svgWidth - getLabelWidth();
  const defs = svg.append('defs');
  const labelSelectionsG = svg.append('g').attr('class', 'labelSelectionsG');
  const clipPath = defs.append('clipPath').attr('id', "".concat(svgId, "-clip"));
  clipPath.append('rect').attr('x', getLabelWidth()).attr('y', 0).attr('width', clipWidth).attr('height', svgHeight);
  const clipG = svg.append('g').attr('class', 'clipG').attr('clip-path', "url(#".concat(svgId, "-clip)"));
  const dragG = clipG.append('g').attr('class', 'dragG');
  const rowSelectionsG = dragG.append('g').attr('class', 'rowSelectionsG');
  const dragContentG = dragG.append('g').attr('class', 'dragContentG');

  /**
     Time offset values and functions
     Setting the time offset (by interacting with the drag group) must
     be sensitive to the previous time offset in the event of a resize
     (e.g. if the time offset is already at the minimum but the minimum
     has changed, prefer it stays at the minimum). Also keep the offset
     bounded within where there's actually data to show.
  */
  let prevMinTimeOffset = getMinTimeOffset();
  if (svg.attr('data-prevMinTimeOffset') === null) {
    svg.attr('data-prevMinTimeOffset', getMinTimeOffset());
  } else {
    prevMinTimeOffset = parseFloat(svg.attr('data-prevMinTimeOffset'));
  }
  const getTimeOffset = () => {
    const minTimeOffset = getMinTimeOffset();
    let currentTimeOffset = parseFloat(svg.attr('data-timeOffset')) || 0;
    if (currentTimeOffset === prevMinTimeOffset && prevMinTimeOffset !== minTimeOffset) {
      currentTimeOffset = minTimeOffset;
      prevMinTimeOffset = minTimeOffset;
      svg.attr('data-prevMinTimeOffset', minTimeOffset);
    }
    return currentTimeOffset;
  };
  const setTimeOffset = timeOffset => {
    // Only set the timeOffset is sites are loaded
    if (!Object.keys(allSites).length) {
      return;
    }
    const boundedTimeOffset = Math.min(Math.max(getMinTimeOffset(), timeOffset), 0);
    dragG.attr('transform', "translate(".concat(boundedTimeOffset, ",0)"));
    svg.attr('data-timeOffset', boundedTimeOffset);
  };
  // Set timeOffset the first time. It's preserved through state updates
  // but we still send its value through the setter to stay within bounds.
  if (svg.attr('data-timeOffset') === null) {
    setTimeOffset(getInitialTimeOffset());
  } else {
    setTimeOffset(svg.attr('data-timeOffset'));
  }

  /**
     Setup: Functions to translate yearMonth gutter centers to pixel offsets and back,
     and other helpers for giving the date range drag handles a snappy feel
  */
  // Get the center of the gutter on either side of a given yearMonth INSIDE the clip.
  // To translate the value to pixels OUTSIDE the clip add the time offset, e.g.:
  //   getYearMonthGutterX('YYYY-MM') + getTimeOffset();
  const getYearMonthGutterX = function (yearMonth) {
    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'left';
    switch (side) {
      case 'left':
        if (yearMonth === _AvailabilityUtils.TIME.MIN_YEAR_MONTH) {
          return getLabelWidth();
        }
        if (yearMonth.substr(5, 2) === '01') {
          return getYearStartX(yearMonth.substr(0, 4)) - _AvailabilityUtils.SVG.YEAR_PADDING / 2;
        }
        return getYearMonthStartX(yearMonth) - _AvailabilityUtils.SVG.CELL_PADDING / 2;
      case 'right':
        if (yearMonth === _AvailabilityUtils.TIME.MAX_YEAR_MONTH) {
          return svgWidth - getTimeOffset();
        }
        if (yearMonth.substr(5, 2) === '12') {
          return getYearStartX(yearMonth.substr(0, 4)) + _AvailabilityUtils.SVG.YEAR_WIDTH + _AvailabilityUtils.SVG.YEAR_PADDING / 2;
        }
        return getYearMonthStartX(yearMonth) + _AvailabilityUtils.SVG.CELL_WIDTH + _AvailabilityUtils.SVG.CELL_PADDING / 2;
      default:
        return getYearMonthStartX(yearMonth) - _AvailabilityUtils.SVG.CELL_PADDING / 2;
    }
  };
  // Get the yearMonth string that's next to a given yearMonth on either side.
  // Stays within the selectable range unless selectable is false, in which case
  // it stays within the chart's global min and max.
  /*
  const getAdjacentYearMonth = (yearMonth, side = 'left', selectable = true) => {
    const year = parseInt(yearMonth.substr(0, 4), 10);
    const month = parseInt(yearMonth.substr(5, 2), 10);
    const bounds = selectable ? dateRange.validValues : [TIME.MIN_YEAR_MONTH, TIME.MAX_YEAR_MONTH];
    let adjacent = yearMonth;
    switch (side) {
      case 'left':
        if (month === 1) {
          adjacent = `${year - 1}-12`;
        } else {
          adjacent = `${year}-${(month - 1).toString().padStart(2, '0')}`;
        }
        return adjacent < bounds[0] ? bounds[0] : adjacent;
      case 'right':
        if (month === 12) {
          adjacent = `${year + 1}-01`;
        } else {
          adjacent = `${year}-${(month + 1).toString().padStart(2, '0')}`;
        }
        return adjacent > bounds[1] ? bounds[1] : adjacent;
      default:
        return adjacent;
    }
  };
  */
  // Get the string for the yearmonth closest to a given pixel x-offset on either side.
  // Stays within the selectable range unless selectable is false, in which case
  // it stays within the chart's global min and max.
  const getXOffsetYearMonth = function (xOffset, dragOffset) {
    let side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'left';
    let selectable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    /***/
    const basis = Math.min(Math.max(xOffset, getLabelWidth()), svgWidth) - dragOffset;
    const yearIdx = Math.floor((basis - getLabelWidth()) / (_AvailabilityUtils.SVG.YEAR_WIDTH + _AvailabilityUtils.SVG.YEAR_PADDING));
    const boundedYearIdx = Math.max(Math.min(yearIdx, _AvailabilityUtils.TIME.YEARS.length - 1), 0);
    let year = _AvailabilityUtils.TIME.YEARS[boundedYearIdx];
    let yearStartX = getYearStartX(year);
    if (basis < yearStartX && side === 'left' && boundedYearIdx !== 0) {
      year = parseInt(year, 10) - 1;
      yearStartX = getYearStartX(year);
    } else if (basis > yearStartX + _AvailabilityUtils.SVG.YEAR_WIDTH && side === 'right' && boundedYearIdx !== _AvailabilityUtils.TIME.YEARS.length - 1) {
      year = parseInt(year, 10) + 1;
      yearStartX = getYearStartX(year);
    }
    const roundFunc = side === 'left' ? 'floor' : 'ceil';
    const month = Math[roundFunc]((basis - yearStartX) / _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH) + 1;
    const boundedMonth = Math.max(Math.min(month, 12), 1);
    const yearMonth = "".concat(year, "-").concat(boundedMonth.toString().padStart(2, '0'));
    const bounds = selectable ? dateRange.validValues : [_AvailabilityUtils.TIME.MIN_YEAR_MONTH, _AvailabilityUtils.TIME.MAX_YEAR_MONTH];
    if (yearMonth < bounds[0]) {
      return bounds[0];
    }
    if (yearMonth > bounds[1]) {
      return bounds[1];
    }
    return yearMonth;
  };

  /**
     SVG: Row Hover
   */
  const rowHover = svg.append('rect').attr('class', 'rowHover');
  rowHover.attr('x', 1).attr('y', -2 * _AvailabilityUtils.SVG.CELL_HEIGHT).attr('width', svgWidth - 1).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', 'none').attr('stroke', _Theme.COLORS.LIGHT_BLUE[700]).attr('stroke-width', '1.5px').style('opacity', 0);

  /**
     SVG: Left and Right bounds
  */
  const lboundOffset = getLabelWidth() + _AvailabilityUtils.SVG.CELL_PADDING / 2 - 1;
  const lbound = svg.append('line');
  lbound.attr('x1', lboundOffset).attr('y1', 0).attr('x2', lboundOffset).attr('y2', svgHeight);
  _AvailabilityUtils.SVG_STYLES.apply(lbound, 'timeBound');
  const rboundOffset = svgWidth - 1;
  const rbound = svg.append('line');
  rbound.attr('x1', rboundOffset).attr('y1', 0).attr('x2', rboundOffset).attr('y2', svgHeight);
  _AvailabilityUtils.SVG_STYLES.apply(rbound, 'timeBound');

  /**
     SVG: Selections
     Create a mapping of current view keys (sites, domains, states, etc.)
     to selected status (i.e. 'full' or 'partial')
  */
  const viewSelections = {};
  const sitesSet = new Set(sites.value);
  const validSitesSet = new Set(sites.validValues);
  if (sites.value.length) {
    switch (data.view) {
      case 'summary':
        viewSelections.summary = sites.value.length === sites.validValues.length ? 'full' : 'partial';
        break;
      case 'sites':
      case 'ungrouped':
        sites.value.forEach(site => {
          viewSelections[site] = 'full';
        });
        break;
      default:
        // domains, states
        Object.keys(siteViewMaps[data.view]).forEach(entry => {
          const viewSites = new Set(siteViewMaps[data.view][entry].filter(s => validSitesSet.has(s)));
          const intersection = new Set([...viewSites].filter(s => sitesSet.has(s)));
          if (!intersection.size) {
            return;
          }
          viewSelections[entry] = intersection.size === viewSites.size ? 'full' : 'partial';
        });
        break;
    }
  }
  const toggleSelection = key => {
    if (!setSitesValue) {
      return;
    }
    let allSitesForKey = new Set();
    switch (data.view) {
      case 'summary':
        allSitesForKey = new Set(sites.validValues);
        break;
      case 'sites':
      case 'ungrouped':
        allSitesForKey = new Set([key]);
        break;
      default:
        // domains, states
        allSitesForKey = new Set(siteViewMaps[data.view][key].filter(s => validSitesSet.has(s)));
        break;
    }
    let newSelectedSitesSet;
    if (!viewSelections[key] || viewSelections[key] === 'partial') {
      // select all sites for this key
      newSelectedSitesSet = new Set([...sitesSet, ...allSitesForKey]);
    } else {
      // deselect all sites for this key
      newSelectedSitesSet = new Set([...sitesSet].filter(s => !allSitesForKey.has(s)));
    }
    setSitesValue([...newSelectedSitesSet]);
  };
  const rowHighlightReset = (0, _lodash.debounce)(function () {
    let clearRowHoverKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (clearRowHoverKey) {
      rowHoverKey = null;
    }
    rowHover.style('opacity', 0);
    rowHover.attr('y', -2 * _AvailabilityUtils.SVG.CELL_HEIGHT);
  }, 100);
  const rowHighlightHover = key => {
    rowHoverKey = key;
    const offset = rowKeys.indexOf(key);
    if (offset !== -1 && !draggingCells) {
      rowHighlightReset.cancel();
      const y = _AvailabilityUtils.SVG.CELL_PADDING / 2 + (rowCount - offset) * (_AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING);
      rowHover.style('opacity', 1);
      rowHover.attr('y', y);
    }
  };

  /**
     SVG: Row Labels
  */
  const rowLabelsG = svg.append('g').attr('class', 'rowLabelsG');
  rowKeys.forEach((rowKey, rowIdx) => {
    const transform = getRowTranslation(rowKey, rowIdx);
    const labelX = getLabelWidth() - _AvailabilityUtils.SVG.CELL_PADDING;
    const rowLabelG = rowLabelsG.append('g').attr('transform', transform);
    const fill = selectionEnabled && setSitesValue && viewSelections[rowKey] ? _Theme.default.palette.primary.contrastText : _Theme.default.palette.grey[700];
    const text = rowLabelG.append('text').attr('x', labelX).attr('y', _AvailabilityUtils.SVG.LABEL_FONT_SIZE - _AvailabilityUtils.SVG.CELL_PADDING / 2).attr('fill', fill).text(data.getLabel.text(rowKey));
    _AvailabilityUtils.SVG_STYLES.apply(text, 'rowLabel');
    const mask = rowLabelG.append('rect').attr('x', 0).attr('y', -1 * (_AvailabilityUtils.SVG.CELL_PADDING / 2)).attr('width', getLabelWidth()).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).on('mouseover', (event, d) => rowHighlightHover(rowKey)).on('focus', (event, d) => rowHighlightHover(rowKey)).on('mouseout', (event, d) => rowHighlightReset(true)).on('blur', (event, d) => rowHighlightReset(true));
    _AvailabilityUtils.SVG_STYLES.apply(mask, 'rowLabelMask');
    // Fill the mask and delay the selection to emulate a touch ripple.
    // Re-render to show the selection will reset the style.
    const maskClick = selectionEnabled && setSitesValue ? (event, d) => {
      _AvailabilityUtils.SVG_STYLES.touchRipple(mask, 15);
      setTimeout(() => toggleSelection(rowKey), 15);
    } : (event, d) => {};
    mask.on('click', maskClick);
    mask.append('svg:title').text(data.getLabel.title(rowKey));
  });

  /**
     SVG: Time Axis
  */
  const timeAxis = {};
  timeAxis.g = dragContentG.append('g').attr('class', 'timeAxisG');
  timeAxis.highlight = timeAxis.g.append('rect').attr('class', 'timeAxisHighlight');
  timeAxis.innerG = timeAxis.g.append('g').attr('class', 'timeAxisInnerG');
  timeAxis.mask = clipG.append('rect').attr('class', 'timeAxisMask');
  const redrawTimeAxis = () => {
    if (timeAxis.innerG.selectAll('*').empty()) {
      timeAxis.highlight.attr('x', getLabelWidth()).attr('y', 0).attr('width', _AvailabilityUtils.SVG.ABS_MAX_DATA_WIDTH).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + 1.5 * _AvailabilityUtils.SVG.CELL_PADDING);
      _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlight');
      timeAxis.mask.attr('x', getLabelWidth()).attr('y', 0).attr('width', _AvailabilityUtils.SVG.ABS_MAX_DATA_WIDTH).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING);
      _AvailabilityUtils.SVG_STYLES.apply(timeAxis.mask, 'timeHighlightMask');
    }
    timeAxis.innerG.selectAll('text').data(() => getYearsInView(svgWidth, getTimeOffset())).join('text').attr('x', year => getYearCenterX(year)).attr('y', _AvailabilityUtils.SVG.LABEL_FONT_SIZE + 1).text(year => year).each((year, idx, labelNodes) => {
      _AvailabilityUtils.SVG_STYLES.apply((0, _d3Selection.select)(labelNodes[idx]), 'timeLabel');
    });
    timeAxis.innerG.selectAll('line').data(() => {
      const lineYears = getYearsInView(svgWidth, getTimeOffset());
      return lineYears[0] === _AvailabilityUtils.TIME.START_YEAR ? lineYears.slice(1) : lineYears;
    }).join('line').attr('x1', year => getYearStartX(year) - _AvailabilityUtils.SVG.YEAR_PADDING / 2).attr('y1', 0).attr('x2', year => getYearStartX(year) - _AvailabilityUtils.SVG.YEAR_PADDING / 2).attr('y2', svgHeight).each((year, idx, lineNodes) => {
      _AvailabilityUtils.SVG_STYLES.apply((0, _d3Selection.select)(lineNodes[idx]), 'timeDivider');
    });
  };

  /**
     SVG: Row Data
  */
  const dataG = dragContentG.append('g').attr('class', 'dataG');
  const dataMasksG = svg.append('g').attr('class', 'dataMasksG');
  const redrawData = () => {
    // Click/drag masks
    dataMasksG.selectAll('rect').data(rowKeys).join('rect').attr('x', getLabelWidth()).attr('y', (d, idx) => _AvailabilityUtils.SVG.CELL_PADDING / 2 + (rowCount - idx) * (_AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING)).attr('width', svgWidth - getLabelWidth()).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', 'transparent').style('cursor', selectionEnabled && setSitesValue ? 'pointer' : 'grab').style('outline', 'none').on('mouseover', (event, d) => rowHighlightHover(d)).on('focus', (event, d) => rowHighlightHover(d)).on('mouseout', (event, d) => rowHighlightReset(true)).on('blur', (event, d) => rowHighlightReset(true)).on('click', selectionEnabled && setSitesValue ? (event, d) => {
      _AvailabilityUtils.SVG_STYLES.touchRipple((0, _d3Selection.select)(event.currentTarget), 15);
      setTimeout(() => toggleSelection(d), 15);
    } : (event, d) => {});
    // Cells
    dataG.selectAll('g').data(rowKeys).join('g').attr('transform', getRowTranslation).each((rowKey, rowIdx, gNodes) => {
      const rowData = data.rows[rowKey];
      const getCellAttr = (month, attr) => {
        const status = (0, _AvailabilityUtils.calcBasicRollupStatus)(rowData[month]);
        return !_AvailabilitySvgComponents.CELL_ATTRS[status] ? _AvailabilitySvgComponents.CELL_ATTRS['not available'][attr] || null : _AvailabilitySvgComponents.CELL_ATTRS[status][attr] || null;
      };
      (0, _d3Selection.select)(gNodes[rowIdx]).selectAll('rect').data(() => getYearMonthsInView(svgWidth, getTimeOffset())).join('rect').attr('cursor', 'pointer').attr('x', month => getYearMonthStartX(month) + (getCellAttr(month, 'nudge') || 0)).attr('y', month => getCellAttr(month, 'nudge') || 0).attr('rx', "".concat(_AvailabilityUtils.SVG.CELL_RX, "px")).attr('width', month => getCellAttr(month, 'width')).attr('height', month => getCellAttr(month, 'height')).attr('fill', month => getCellAttr(month, 'fill')).attr('stroke', month => getCellAttr(month, 'stroke')).attr('stroke-width', month => getCellAttr(month, 'strokeWidth'));
    });
  };

  /**
     SVG: Date Range Handles
  */
  const dateRangeHandlesG = selectionEnabled ? dragG.append('g').attr('class', 'dateRangeHandlesG') : null;
  const redrawDateRangeHandles = () => {
    if (!selectionEnabled) {
      return;
    }
    const isHighlighted = d => dateRangeHoverKey === d || draggingDateRange[d].dragging;
    const yBounds = Object.keys(viewSelections).reduce((acc, key) => {
      const y = getRowY(rowKeys.indexOf(key));
      const low = y - _AvailabilityUtils.SVG.CELL_PADDING / 2;
      const high = y + _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING / 2;
      return [acc[0] === null || acc[0] > low ? low : acc[0], acc[1] === null || acc[1] < high ? high : acc[1]];
    }, [null, null]);
    dateRangeHandlesG.selectAll('rect').data([0, 1]).join('rect').attr('class', d => "dateRange".concat(d === 0 ? 'Start' : 'End', "HandleRect")).attr('x', d => {
      const useWidth = isHighlighted(d) ? _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH + 2 : _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH;
      const gutterX = getYearMonthGutterX(dateRange.value[d], d === 0 ? 'left' : 'right');
      if (d === 0 && dateRange.value[d] === _AvailabilityUtils.TIME.MIN_YEAR_MONTH) {
        return gutterX;
      }
      if (d === 1 && dateRange.value[d] === _AvailabilityUtils.TIME.MAX_YEAR_MONTH) {
        return gutterX - useWidth;
      }
      return gutterX - useWidth / 2;
    }).attr('width', d => isHighlighted(d) ? _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH + 2 : _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH).attr('y', d => {
      if (isHighlighted(d)) {
        return getRowY(rowKeys.length - 1) - _AvailabilityUtils.SVG.CELL_PADDING / 2;
      }
      return yBounds[0];
    }).attr('height', d => {
      if (isHighlighted(d)) {
        return svgHeight - getRowY(rowKeys.length - 1) + _AvailabilityUtils.SVG.CELL_PADDING / 2 - 0.5;
      }
      return yBounds[1] - yBounds[0];
    }).attr('fill', d => isHighlighted(d) ? _Theme.COLORS.LIGHT_BLUE[100] : _Theme.COLORS.LIGHT_BLUE[300]).attr('stroke', _Theme.default.palette.primary.main).style('stroke-width', '1.5px').style('display', sites.value.length ? null : 'none');
  };

  /**
     SVG: Date Range Masks
  */
  const dateRangeMasksG = selectionEnabled ? svg.append('g').attr('class', 'dateRangeMasksG') : null;
  const redrawDateRangeHandleMasks = () => {
    if (!selectionEnabled) {
      return;
    }
    dateRangeMasksG.selectAll('rect').data([0, 1]).join('rect').attr('class', d => "dateRange".concat(d === 0 ? 'Start' : 'End', "MaskRect")).attr('x', d => getYearMonthGutterX(dateRange.value[d] || _AvailabilityUtils.TIME.MIN_YEAR_MONTH, d === 0 ? 'left' : 'right') - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2 + getTimeOffset()).attr('y', 0).attr('width', _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH).attr('height', svgHeight).style('cursor', 'crosshair') // 'ew-resize'
    .style('outline', 'none').attr('fill', 'red').style('opacity', 0).style('display', sites.value.length ? null : 'none');
  };

  /**
     SVG: Selections
  */
  const redrawSelections = () => {
    if (!selectionEnabled) {
      return;
    }

    // Row and label backgrounds
    const yOffset = _AvailabilityUtils.SVG.CELL_PADDING / 2;
    const yMultiplier = _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING;
    const y = d => yOffset + (rowCount - rowKeys.indexOf(d)) * yMultiplier;
    const fill = d => viewSelections[d] === 'full' ? _Theme.default.palette.primary.main : _Theme.COLORS.LIGHT_BLUE[200];
    let startX = getYearMonthGutterX(dateRange.value[0], 'left');
    let endX = getYearMonthGutterX(dateRange.value[1], 'right');
    if (startX > endX) {
      const swapX = startX;
      startX = endX;
      endX = swapX;
    }
    rowSelectionsG.selectAll('rect').data(Object.keys(viewSelections)).join('rect').attr('x', startX).attr('y', y).attr('width', endX - startX).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', fill);
    if (setSitesValue) {
      labelSelectionsG.selectAll('rect').data(Object.keys(viewSelections)).join('rect').attr('x', 0).attr('y', y).attr('width', getLabelWidth()).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', fill);
    }

    // Date range handles
    redrawDateRangeHandles();
  };

  /**
     Redraw functions
  */
  const redraw = () => {
    redrawTimeAxis();
    redrawData();
    if (selectionEnabled) {
      redrawSelections();
    }
  };
  // const debouncedRedraw = debounce(redraw, 150);

  /**
     Invoke initial redraws
  */
  redraw();
  redrawDateRangeHandleMasks();

  /**
     Setup Interactions
  */
  const timeHighlightReset = (0, _lodash.debounce)(() => {
    if (draggingCells) {
      return;
    }
    dataMasksG.selectAll('rect').style('cursor', selectionEnabled ? 'pointer' : 'grab');
    timeAxis.mask.style('cursor', 'grab');
    _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlight');
  }, 100);
  const timeHighlightHover = () => {
    if (draggingCells) {
      return;
    }
    timeHighlightReset.cancel();
    _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlightHover');
  };
  let cellDragTime = null;
  const dragCells = (0, _d3Drag.drag)().on('start', (event, d) => {
    draggingCells = true;
    rowHighlightReset(false);
    dataMasksG.selectAll('rect').style('cursor', 'grabbing');
    timeAxis.mask.style('cursor', 'grabbing');
    _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlightDrag');
    cellDragTime = new Date().getTime();
  }).on('drag', (event, d) => {
    setTimeOffset(getTimeOffset() + event.dx);
    redrawData();
    redrawDateRangeHandleMasks();
  }).on('end', (event, d) => {
    draggingCells = false;
    rowHighlightHover(rowHoverKey);
    timeHighlightReset();
    redraw();
    redrawDateRangeHandleMasks();
    // If the drag was less than 1/10 of a second long assume it's a sloppy click.
    // Perform a select action if selection is enabled to keep the end user happy. =)
    cellDragTime = new Date().getTime() - cellDragTime;
    if (selectionEnabled && setSitesValue && cellDragTime < 100) {
      _AvailabilityUtils.SVG_STYLES.touchRipple(dataMasksG.selectAll('rect').filter(filterD => filterD === rowHoverKey), 15);
      setTimeout(() => toggleSelection(rowHoverKey), 15);
    }
  });
  dragCells(timeAxis.mask);
  dragCells(dataMasksG.selectAll('rect'));
  timeAxis.mask.on('wheel', (event, d) => {
    event.preventDefault();
    const step = (_AvailabilityUtils.SVG.CELL_WIDTH + _AvailabilityUtils.SVG.CELL_PADDING) * 3;
    const delta = (event.wheelDelta > 0 ? -1 : 1) * step;
    setTimeOffset(getTimeOffset() + delta);
    redraw();
    redrawDateRangeHandleMasks();
  }).on('mouseover', (event, d) => timeHighlightHover()).on('focus', (event, d) => timeHighlightHover()).on('mouseout', (event, d) => timeHighlightReset()).on('blur', (event, d) => timeHighlightReset());
  if (selectionEnabled) {
    const dateRangeHandleReset = (0, _lodash.debounce)(() => {
      dateRangeHoverKey = null;
      redrawDateRangeHandles();
    }, 100);
    const dateRangeHandleHover = key => {
      dateRangeHoverKey = key;
      redrawDateRangeHandles();
    };

    // Function to flip date range handles, masks, and values if a drag event puts start after end
    // Shift values by one month on each side if flipping as start looks ahead and end looks back
    const flipDateRangeSelectionIfNeeded = () => {
      if (dateRange.value[1] < dateRange.value[0]) {
        dateRange.value = [_AvailabilityUtils.TIME.getNextMonth(dateRange.value[1]), _AvailabilityUtils.TIME.getPreviousMonth(dateRange.value[0])];
        // Only if the handles are atop each other will this still be true after the last flip.
        // In this case hard set to the same value (so one month selected).
        if (dateRange.value[1] < dateRange.value[0]) {
          dateRange.value[0] = dateRange.value[1]; // eslint-disable-line prefer-destructuring
        }
      }
    };

    // Interactions for Date Range START Handle
    const dragDateRangeStartMask = dateRangeMasksG.select('.dateRangeStartMaskRect');
    dragDateRangeStartMask.on('mouseover', (event, d) => dateRangeHandleHover(0)).on('focus', (event, d) => dateRangeHandleHover(0)).on('mouseout', (event, d) => dateRangeHandleReset()).on('blur', (event, d) => dateRangeHandleReset());
    const dragDateRangeStart = (0, _d3Drag.drag)().on('start', (event, d) => {
      draggingDateRange[0].dragging = true;
      draggingDateRange[0].centerDragX = parseFloat(dragDateRangeStartMask.attr('x'), 10) + _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2;
    }).on('drag', (event, d) => {
      draggingDateRange[0].centerDragX += event.dx;
      const {
        centerDragX
      } = draggingDateRange[0];
      dragDateRangeStartMask.attr('x', centerDragX - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2);
      const nextYearMonth = getXOffsetYearMonth(centerDragX, getTimeOffset(), 'right');
      const nextYearMonthStartX = getYearMonthGutterX(nextYearMonth, 'left');
      const currentYearMonthStartX = getYearMonthGutterX(dateRange.value[0], 'left');
      const insideClipCenterDragX = draggingDateRange[0].centerDragX - getTimeOffset();
      const distanceToNext = Math.abs(insideClipCenterDragX - nextYearMonthStartX);
      const distanceToCurrent = Math.abs(insideClipCenterDragX - currentYearMonthStartX);
      if (nextYearMonth !== dateRange.value[0] && distanceToNext < distanceToCurrent) {
        dateRange.value[0] = nextYearMonth;
        redrawSelections();
      }
    }).on('end', (event, d) => {
      draggingDateRange[0].dragging = false;
      draggingDateRange[0].centerDragX = 0;
      // Recenter mask as it is likely off a few pixels due to snap-to-gutter behavior
      const maskX = getYearMonthGutterX(dateRange.value[0], 'left') + _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2 + getTimeOffset();
      dateRangeMasksG.select('.dateRangeStartMaskRect').attr('x', maskX);
      flipDateRangeSelectionIfNeeded();
      setDateRangeValue([...dateRange.value]);
      redrawSelections();
    });
    dragDateRangeStart(dateRangeMasksG.select('.dateRangeStartMaskRect'));

    // Interactions for Date Range END Handle
    const dragDateRangeEndMask = dateRangeMasksG.select('.dateRangeEndMaskRect');
    dragDateRangeEndMask.on('mouseover', (event, d) => dateRangeHandleHover(1)).on('focus', (event, d) => dateRangeHandleHover(1)).on('mouseout', (event, d) => dateRangeHandleReset()).on('blur', (event, d) => dateRangeHandleReset());
    const dragDateRangeEnd = (0, _d3Drag.drag)().on('start', (event, d) => {
      draggingDateRange[1].dragging = true;
      draggingDateRange[1].centerDragX = parseFloat(dragDateRangeEndMask.attr('x'), 10) + _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2;
    }).on('drag', (event, d) => {
      draggingDateRange[1].centerDragX += event.dx;
      const {
        centerDragX
      } = draggingDateRange[1];
      dragDateRangeEndMask.attr('x', centerDragX - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2);
      const nextYearMonth = getXOffsetYearMonth(centerDragX, getTimeOffset(), 'left');
      const nextYearMonthEndX = getYearMonthGutterX(nextYearMonth, 'right');
      const currentYearMonthEndX = getYearMonthGutterX(dateRange.value[1], 'right');
      const insideClipCenterDragX = draggingDateRange[1].centerDragX - getTimeOffset();
      const distanceToNext = Math.abs(insideClipCenterDragX - nextYearMonthEndX);
      const distanceToCurrent = Math.abs(insideClipCenterDragX - currentYearMonthEndX);
      if (nextYearMonth !== dateRange.value[1] && distanceToNext < distanceToCurrent) {
        dateRange.value[1] = nextYearMonth;
        redrawSelections();
      }
    }).on('end', (event, d) => {
      draggingDateRange[1].dragging = false;
      draggingDateRange[1].centerDragX = 0;
      // Recenter mask as it is likely off a few pixels due to snap-to-gutter behavior
      const maskX = getYearMonthGutterX(dateRange.value[1], 'right') - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2 + getTimeOffset();
      dateRangeMasksG.select('.dateRangeEndMaskRect').attr('x', maskX);
      flipDateRangeSelectionIfNeeded();
      setDateRangeValue([...dateRange.value]);
      redrawSelections();
    });
    dragDateRangeEnd(dateRangeMasksG.select('.dateRangeEndMaskRect'));
  }
}