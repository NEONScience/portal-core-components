"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BasicAvailabilityGrid;
var _lodash = require("lodash");
var _d3Selection = require("d3-selection");
var _d3Drag = require("d3-drag");
var _uniqueId = _interopRequireDefault(require("lodash/uniqueId"));
var _Theme = _interopRequireWildcard(require("../Theme/Theme"));
var _AvailabilityUtils = require("./AvailabilityUtils");
var _AvailabilitySvgComponents = require("./AvailabilitySvgComponents");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * BasicAvailabilityGrid generator function
 * @param {object} config - all arguments, see below:
 * * @param {object} svgRef Pointer to an <svg> element generated by useRef()
 * * @param {object} data View object containing name, rows, and getLabel functions
 * * @param {object} sites
 * * * @param {array} value Array of site code strings to show as selected
 * * * @param {array} validValues Array of site code strings known to have some data
 *         in the data set. This is only superfluous when the view is "site". Otherwise,
 *         for example, clicking the summary view row has no way of knowing the specific
 *         sites that actually apply when "selecting all" for this particular product
 * * @param {function} setSitesValue Setter from useState hook defined in
 *       parent to set state for sites
 * * @param {object} dateRange
 * * * @param {array} value Array of exactly two "YYYY-MM" strings
 * * * @param {array} validValues Array of exactly two "YYYY-MM" strings
 *       representing the limits of available / selectable data for the product
 * * @param {function} setDateRangeValue Setter from useState hook defined in
 *       parent to set state for dateRange
 * * @param {boolean} selectionEnabled Whether to hook up interactions to allow
 *       user selection of sites
 */
function BasicAvailabilityGrid(config) {
  /**
     Extract Config
  */
  var svgRef = config.svgRef,
    data = config.data,
    _config$sites = config.sites,
    sites = _config$sites === void 0 ? {
      value: [],
      validValues: []
    } : _config$sites,
    _config$allSites = config.allSites,
    allSites = _config$allSites === void 0 ? {} : _config$allSites,
    _config$sortedSites = config.sortedSites,
    sortedSites = _config$sortedSites === void 0 ? [] : _config$sortedSites,
    _config$setSitesValue = config.setSitesValue,
    setSitesValue = _config$setSitesValue === void 0 ? null : _config$setSitesValue,
    _config$dateRange = config.dateRange,
    dateRange = _config$dateRange === void 0 ? {
      value: [],
      validValues: [_AvailabilityUtils.TIME.MIN_YEAR_MONTH, _AvailabilityUtils.TIME.MAX_YEAR_MONTH]
    } : _config$dateRange,
    _config$setDateRangeV = config.setDateRangeValue,
    setDateRangeValue = _config$setDateRangeV === void 0 ? function () {} : _config$setDateRangeV,
    _config$selectionEnab = config.selectionEnabled,
    selectionEnabled = _config$selectionEnab === void 0 ? true : _config$selectionEnab;

  /**
     Sanity Check: svgRef must be a valid ref
  */
  if (!svgRef || !svgRef.current) {
    return null;
  }

  /**
     Sanity Check: data must exist and have rows
  */
  if (!data || !data.rows) {
    return null;
  }

  /**
     Setup: Inputs and Base Values
  */
  var svg = (0, _d3Selection.select)(svgRef.current);
  if (svg.attr('id') === null) {
    svg.attr('id', "availability-".concat((0, _uniqueId.default)()));
  }
  var svgId = svg.attr('id');
  var svgWidth = parseFloat(svg.attr('width'));
  var svgHeight = parseFloat(svg.attr('height'));
  var rowKeys = sortedSites.length ? sortedSites : Object.keys(data.rows).sort().reverse();
  var rowCount = rowKeys.length;

  /**
     Sanity Check: svg must have discrete numeric dimensions
  */
  if (Number.isNaN(svgWidth) || Number.isNaN(svgHeight)) {
    return null;
  }

  /**
     Setup: Static site/domain/state data
     Create mappings of all sites for given state or domain
     to aid in showing partial vs. full selections
  */
  var siteViewMaps = {
    domains: {},
    states: {}
  };
  Object.keys(allSites).forEach(function (site) {
    var domain = allSites[site].domainCode;
    if (!siteViewMaps.domains[domain]) {
      siteViewMaps.domains[domain] = [];
    }
    siteViewMaps.domains[domain].push(site);
    var state = allSites[site].stateCode;
    if (!siteViewMaps.states[state]) {
      siteViewMaps.states[state] = [];
    }
    siteViewMaps.states[state].push(site);
  });

  /**
     Setup: Interaction state vars (local vars is all we need here)
  */
  var rowHoverKey = null;
  var draggingCells = false;

  /* eslint-disable no-unused-vars */
  var dateRangeHoverKey = null;
  var draggingDateRange = [{
    dragging: false,
    centerDragX: 0
  }, {
    dragging: false,
    centerDragX: 0
  }];
  /* eslint-enable no-unused-vars */

  /**
     Functions to filter TIME.YEAR_MONTHS and TIME.YEARS to only what's in view
     given the current dragOffset and the clip width. We use this to
     feed data to d3 selections in order to only draw what will actually
     be visible.
  */
  var getLabelWidth = function getLabelWidth() {
    if (data.view === 'products') return _AvailabilityUtils.SVG.PRODUCT_LABEL_WIDTH;
    return data.view === 'ungrouped' ? _AvailabilityUtils.SVG.UNGROUPED_LABEL_WIDTH : _AvailabilityUtils.SVG.GROUPED_LABEL_WIDTH;
  };
  var getMinTimeOffset = function getMinTimeOffset() {
    return 0 - (_AvailabilityUtils.SVG.ABS_MAX_DATA_WIDTH - (svgWidth - getLabelWidth()));
  };
  var getYearStartX = function getYearStartX(year) {
    var intYear = parseInt(year, 10);
    return getLabelWidth() + _AvailabilityUtils.SVG.END_PADDING + _AvailabilityUtils.TIME.YEARS.indexOf(intYear) * (_AvailabilityUtils.SVG.YEAR_WIDTH + _AvailabilityUtils.SVG.YEAR_PADDING);
  };
  var getYearCenterX = function getYearCenterX(year) {
    return getYearStartX(year) + _AvailabilityUtils.SVG.YEAR_WIDTH / 2;
  };
  var getYearMonthStartX = function getYearMonthStartX(yearMonth) {
    var year = parseInt(yearMonth.substr(0, 4), 10);
    var month = parseInt(yearMonth.substr(5, 2), 10);
    var yearIdx = _AvailabilityUtils.TIME.YEARS.indexOf(year);
    if (yearIdx === -1 || month < 1 || month > 12) {
      return 0;
    }
    return getYearStartX(year) + (month - 1) * _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH;
  };
  var getYearMonthsInView = function getYearMonthsInView(totalSvgWidth, dragOffset) {
    return _AvailabilityUtils.TIME.YEAR_MONTHS.filter(function (yearMonth) {
      var tX = getYearMonthStartX(yearMonth) + dragOffset;
      var margin = _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH * 4;
      var lower = Math.max(0, getLabelWidth() - margin);
      var upper = totalSvgWidth + margin;
      return tX > lower && tX + _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH < upper;
    });
  };
  var getYearsInView = function getYearsInView(totalSvgWidth, dragOffset) {
    return _AvailabilityUtils.TIME.YEARS.filter(function (year) {
      var tX = getYearStartX(year) + dragOffset;
      var lower = -2 * _AvailabilityUtils.SVG.YEAR_WIDTH;
      var upper = totalSvgWidth - getLabelWidth() + 2 * _AvailabilityUtils.SVG.YEAR_WIDTH;
      return tX > lower && tX + _AvailabilityUtils.SVG.YEAR_WIDTH < upper;
    });
  };

  /**
     Function to generate the "initial" time offset for first load. By default we may extend the
     viewable time range well beyond available data (e.g. if there is no data this year the chart
     should still show dates for this year so it's not ambiguous). This function aims to generate
     an ideal time offset that will put the latest month with availability in view and close to the
     right edge, but also keeping full year labels in view (why we target 8 months of the latest
     year... the right number of months so the year label is not cut off even if the year is empty)
  */
  var getInitialTimeOffset = function getInitialTimeOffset() {
    var minTimeOffset = getMinTimeOffset();
    if (!data || !data.rows) {
      return minTimeOffset;
    }
    var availableMonths = [];
    if (data.rows.summary) {
      availableMonths = Object.keys(data.rows.summary);
    } else {
      var availableMonthsSet = new Set();
      Object.keys(data.rows).forEach(function (rowKey) {
        Object.keys(data.rows[rowKey]).forEach(availableMonthsSet.add, availableMonthsSet);
      });
      availableMonths = Array.from(availableMonthsSet.values());
    }
    if (!availableMonths.length) {
      return minTimeOffset;
    }
    availableMonths.sort();
    var latestAvailableYearMonth = availableMonths[availableMonths.length - 1];
    var latestAvailableYearInt = parseInt(latestAvailableYearMonth.substr(0, 4), 10);
    var latestAvailableMonthInt = parseInt(latestAvailableYearMonth.substr(5, 2), 10);
    var finalMonth = latestAvailableMonthInt <= 6 ? "".concat(latestAvailableYearInt, "-08") : "".concat(latestAvailableYearInt + 1, "-08");
    return Math.max(0 - getYearMonthStartX(finalMonth) - _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH + svgWidth, minTimeOffset);
  };

  /**
     Functions to get a translate() string for a data row by index
     in the sorted rowKeys array
  */
  var getRowY = function getRowY(idx) {
    return _AvailabilityUtils.SVG.CELL_PADDING + (rowCount - idx) * (_AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING);
  };
  var getRowTranslation = function getRowTranslation(d, idx) {
    return "translate(0,".concat(getRowY(idx), ")");
  };

  /**
     Main SVG Structure
     (Layered groups, clip definition, etc.)
  */
  svg.selectAll('*').remove();
  var clipWidth = svgWidth - getLabelWidth();
  var defs = svg.append('defs');
  var labelSelectionsG = svg.append('g').attr('class', 'labelSelectionsG');
  var clipPath = defs.append('clipPath').attr('id', "".concat(svgId, "-clip"));
  clipPath.append('rect').attr('x', getLabelWidth()).attr('y', 0).attr('width', clipWidth).attr('height', svgHeight);
  var clipG = svg.append('g').attr('class', 'clipG').attr('clip-path', "url(#".concat(svgId, "-clip)"));
  var dragG = clipG.append('g').attr('class', 'dragG');
  var rowSelectionsG = dragG.append('g').attr('class', 'rowSelectionsG');
  var dragContentG = dragG.append('g').attr('class', 'dragContentG');

  /**
     Time offset values and functions
     Setting the time offset (by interacting with the drag group) must
     be sensitive to the previous time offset in the event of a resize
     (e.g. if the time offset is already at the minimum but the minimum
     has changed, prefer it stays at the minimum). Also keep the offset
     bounded within where there's actually data to show.
  */
  var prevMinTimeOffset = getMinTimeOffset();
  if (svg.attr('data-prevMinTimeOffset') === null) {
    svg.attr('data-prevMinTimeOffset', getMinTimeOffset());
  } else {
    prevMinTimeOffset = parseFloat(svg.attr('data-prevMinTimeOffset'));
  }
  var getTimeOffset = function getTimeOffset() {
    var minTimeOffset = getMinTimeOffset();
    var currentTimeOffset = parseFloat(svg.attr('data-timeOffset')) || 0;
    if (currentTimeOffset === prevMinTimeOffset && prevMinTimeOffset !== minTimeOffset) {
      currentTimeOffset = minTimeOffset;
      prevMinTimeOffset = minTimeOffset;
      svg.attr('data-prevMinTimeOffset', minTimeOffset);
    }
    return currentTimeOffset;
  };
  var setTimeOffset = function setTimeOffset(timeOffset) {
    // Only set the timeOffset is sites are loaded
    if (!Object.keys(allSites).length) {
      return;
    }
    var boundedTimeOffset = Math.min(Math.max(getMinTimeOffset(), timeOffset), 0);
    dragG.attr('transform', "translate(".concat(boundedTimeOffset, ",0)"));
    svg.attr('data-timeOffset', boundedTimeOffset);
  };
  // Set timeOffset the first time. It's preserved through state updates
  // but we still send its value through the setter to stay within bounds.
  if (svg.attr('data-timeOffset') === null) {
    setTimeOffset(getInitialTimeOffset());
  } else {
    setTimeOffset(svg.attr('data-timeOffset'));
  }

  /**
     Setup: Functions to translate yearMonth gutter centers to pixel offsets and back,
     and other helpers for giving the date range drag handles a snappy feel
  */
  // Get the center of the gutter on either side of a given yearMonth INSIDE the clip.
  // To translate the value to pixels OUTSIDE the clip add the time offset, e.g.:
  //   getYearMonthGutterX('YYYY-MM') + getTimeOffset();
  var getYearMonthGutterX = function getYearMonthGutterX(yearMonth) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'left';
    switch (side) {
      case 'left':
        if (yearMonth === _AvailabilityUtils.TIME.MIN_YEAR_MONTH) {
          return getLabelWidth();
        }
        if (yearMonth.substr(5, 2) === '01') {
          return getYearStartX(yearMonth.substr(0, 4)) - _AvailabilityUtils.SVG.YEAR_PADDING / 2;
        }
        return getYearMonthStartX(yearMonth) - _AvailabilityUtils.SVG.CELL_PADDING / 2;
      case 'right':
        if (yearMonth === _AvailabilityUtils.TIME.MAX_YEAR_MONTH) {
          return svgWidth - getTimeOffset();
        }
        if (yearMonth.substr(5, 2) === '12') {
          return getYearStartX(yearMonth.substr(0, 4)) + _AvailabilityUtils.SVG.YEAR_WIDTH + _AvailabilityUtils.SVG.YEAR_PADDING / 2;
        }
        return getYearMonthStartX(yearMonth) + _AvailabilityUtils.SVG.CELL_WIDTH + _AvailabilityUtils.SVG.CELL_PADDING / 2;
      default:
        return getYearMonthStartX(yearMonth) - _AvailabilityUtils.SVG.CELL_PADDING / 2;
    }
  };
  // Get the yearMonth string that's next to a given yearMonth on either side.
  // Stays within the selectable range unless selectable is false, in which case
  // it stays within the chart's global min and max.
  /*
  const getAdjacentYearMonth = (yearMonth, side = 'left', selectable = true) => {
    const year = parseInt(yearMonth.substr(0, 4), 10);
    const month = parseInt(yearMonth.substr(5, 2), 10);
    const bounds = selectable ? dateRange.validValues : [TIME.MIN_YEAR_MONTH, TIME.MAX_YEAR_MONTH];
    let adjacent = yearMonth;
    switch (side) {
      case 'left':
        if (month === 1) {
          adjacent = `${year - 1}-12`;
        } else {
          adjacent = `${year}-${(month - 1).toString().padStart(2, '0')}`;
        }
        return adjacent < bounds[0] ? bounds[0] : adjacent;
      case 'right':
        if (month === 12) {
          adjacent = `${year + 1}-01`;
        } else {
          adjacent = `${year}-${(month + 1).toString().padStart(2, '0')}`;
        }
        return adjacent > bounds[1] ? bounds[1] : adjacent;
      default:
        return adjacent;
    }
  };
  */
  // Get the string for the yearmonth closest to a given pixel x-offset on either side.
  // Stays within the selectable range unless selectable is false, in which case
  // it stays within the chart's global min and max.
  var getXOffsetYearMonth = function getXOffsetYearMonth(xOffset, dragOffset) {
    var side = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'left';
    var selectable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    /***/
    var basis = Math.min(Math.max(xOffset, getLabelWidth()), svgWidth) - dragOffset;
    var yearIdx = Math.floor((basis - getLabelWidth()) / (_AvailabilityUtils.SVG.YEAR_WIDTH + _AvailabilityUtils.SVG.YEAR_PADDING));
    var boundedYearIdx = Math.max(Math.min(yearIdx, _AvailabilityUtils.TIME.YEARS.length - 1), 0);
    var year = _AvailabilityUtils.TIME.YEARS[boundedYearIdx];
    var yearStartX = getYearStartX(year);
    if (basis < yearStartX && side === 'left' && boundedYearIdx !== 0) {
      year = parseInt(year, 10) - 1;
      yearStartX = getYearStartX(year);
    } else if (basis > yearStartX + _AvailabilityUtils.SVG.YEAR_WIDTH && side === 'right' && boundedYearIdx !== _AvailabilityUtils.TIME.YEARS.length - 1) {
      year = parseInt(year, 10) + 1;
      yearStartX = getYearStartX(year);
    }
    var roundFunc = side === 'left' ? 'floor' : 'ceil';
    var month = Math[roundFunc]((basis - yearStartX) / _AvailabilityUtils.SVG.YEAR_MONTH_WIDTH) + 1;
    var boundedMonth = Math.max(Math.min(month, 12), 1);
    var yearMonth = "".concat(year, "-").concat(boundedMonth.toString().padStart(2, '0'));
    var bounds = selectable ? dateRange.validValues : [_AvailabilityUtils.TIME.MIN_YEAR_MONTH, _AvailabilityUtils.TIME.MAX_YEAR_MONTH];
    if (yearMonth < bounds[0]) {
      return bounds[0];
    }
    if (yearMonth > bounds[1]) {
      return bounds[1];
    }
    return yearMonth;
  };

  /**
     SVG: Row Hover
   */
  var rowHover = svg.append('rect').attr('class', 'rowHover');
  rowHover.attr('x', 1).attr('y', -2 * _AvailabilityUtils.SVG.CELL_HEIGHT).attr('width', svgWidth - 1).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', 'none').attr('stroke', _Theme.COLORS.LIGHT_BLUE[700]).attr('stroke-width', '1.5px').style('opacity', 0);

  /**
     SVG: Left and Right bounds
  */
  var lboundOffset = getLabelWidth() + _AvailabilityUtils.SVG.CELL_PADDING / 2 - 1;
  var lbound = svg.append('line');
  lbound.attr('x1', lboundOffset).attr('y1', 0).attr('x2', lboundOffset).attr('y2', svgHeight);
  _AvailabilityUtils.SVG_STYLES.apply(lbound, 'timeBound');
  var rboundOffset = svgWidth - 1;
  var rbound = svg.append('line');
  rbound.attr('x1', rboundOffset).attr('y1', 0).attr('x2', rboundOffset).attr('y2', svgHeight);
  _AvailabilityUtils.SVG_STYLES.apply(rbound, 'timeBound');

  /**
     SVG: Selections
     Create a mapping of current view keys (sites, domains, states, etc.)
     to selected status (i.e. 'full' or 'partial')
  */
  var viewSelections = {};
  var sitesSet = new Set(sites.value);
  var validSitesSet = new Set(sites.validValues);
  if (sites.value.length) {
    switch (data.view) {
      case 'summary':
        viewSelections.summary = sites.value.length === sites.validValues.length ? 'full' : 'partial';
        break;
      case 'sites':
      case 'ungrouped':
        sites.value.forEach(function (site) {
          viewSelections[site] = 'full';
        });
        break;
      default:
        // domains, states
        Object.keys(siteViewMaps[data.view]).forEach(function (entry) {
          var viewSites = new Set(siteViewMaps[data.view][entry].filter(function (s) {
            return validSitesSet.has(s);
          }));
          var intersection = new Set(_toConsumableArray(viewSites).filter(function (s) {
            return sitesSet.has(s);
          }));
          if (!intersection.size) {
            return;
          }
          viewSelections[entry] = intersection.size === viewSites.size ? 'full' : 'partial';
        });
        break;
    }
  }
  var toggleSelection = function toggleSelection(key) {
    if (!setSitesValue) {
      return;
    }
    var allSitesForKey = new Set();
    switch (data.view) {
      case 'summary':
        allSitesForKey = new Set(sites.validValues);
        break;
      case 'sites':
      case 'ungrouped':
        allSitesForKey = new Set([key]);
        break;
      default:
        // domains, states
        allSitesForKey = new Set(siteViewMaps[data.view][key].filter(function (s) {
          return validSitesSet.has(s);
        }));
        break;
    }
    var newSelectedSitesSet;
    if (!viewSelections[key] || viewSelections[key] === 'partial') {
      // select all sites for this key
      newSelectedSitesSet = new Set([].concat(_toConsumableArray(sitesSet), _toConsumableArray(allSitesForKey)));
    } else {
      // deselect all sites for this key
      newSelectedSitesSet = new Set(_toConsumableArray(sitesSet).filter(function (s) {
        return !allSitesForKey.has(s);
      }));
    }
    setSitesValue(_toConsumableArray(newSelectedSitesSet));
  };
  var rowHighlightReset = (0, _lodash.debounce)(function () {
    var clearRowHoverKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (clearRowHoverKey) {
      rowHoverKey = null;
    }
    rowHover.style('opacity', 0);
    rowHover.attr('y', -2 * _AvailabilityUtils.SVG.CELL_HEIGHT);
  }, 100);
  var rowHighlightHover = function rowHighlightHover(key) {
    rowHoverKey = key;
    var offset = rowKeys.indexOf(key);
    if (offset !== -1 && !draggingCells) {
      rowHighlightReset.cancel();
      var y = _AvailabilityUtils.SVG.CELL_PADDING / 2 + (rowCount - offset) * (_AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING);
      rowHover.style('opacity', 1);
      rowHover.attr('y', y);
    }
  };

  /**
     SVG: Row Labels
  */
  var rowLabelsG = svg.append('g').attr('class', 'rowLabelsG');
  rowKeys.forEach(function (rowKey, rowIdx) {
    var transform = getRowTranslation(rowKey, rowIdx);
    var labelX = getLabelWidth() - _AvailabilityUtils.SVG.CELL_PADDING;
    var rowLabelG = rowLabelsG.append('g').attr('transform', transform);
    var fill = selectionEnabled && setSitesValue && viewSelections[rowKey] ? _Theme.default.palette.primary.contrastText : _Theme.default.palette.grey[700];
    var text = rowLabelG.append('text').attr('x', labelX).attr('y', _AvailabilityUtils.SVG.LABEL_FONT_SIZE - _AvailabilityUtils.SVG.CELL_PADDING / 2).attr('fill', fill).text(data.getLabel.text(rowKey));
    _AvailabilityUtils.SVG_STYLES.apply(text, 'rowLabel');
    var mask = rowLabelG.append('rect').attr('x', 0).attr('y', -1 * (_AvailabilityUtils.SVG.CELL_PADDING / 2)).attr('width', getLabelWidth()).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).on('mouseover', function (event, d) {
      return rowHighlightHover(rowKey);
    }).on('focus', function (event, d) {
      return rowHighlightHover(rowKey);
    }).on('mouseout', function (event, d) {
      return rowHighlightReset(true);
    }).on('blur', function (event, d) {
      return rowHighlightReset(true);
    });
    _AvailabilityUtils.SVG_STYLES.apply(mask, 'rowLabelMask');
    // Fill the mask and delay the selection to emulate a touch ripple.
    // Re-render to show the selection will reset the style.
    var maskClick = selectionEnabled && setSitesValue ? function (event, d) {
      _AvailabilityUtils.SVG_STYLES.touchRipple(mask, 15);
      setTimeout(function () {
        return toggleSelection(rowKey);
      }, 15);
    } : function (event, d) {};
    mask.on('click', maskClick);
    mask.append('svg:title').text(data.getLabel.title(rowKey));
  });

  /**
     SVG: Time Axis
  */
  var timeAxis = {};
  timeAxis.g = dragContentG.append('g').attr('class', 'timeAxisG');
  timeAxis.highlight = timeAxis.g.append('rect').attr('class', 'timeAxisHighlight');
  timeAxis.innerG = timeAxis.g.append('g').attr('class', 'timeAxisInnerG');
  timeAxis.mask = clipG.append('rect').attr('class', 'timeAxisMask');
  var redrawTimeAxis = function redrawTimeAxis() {
    if (timeAxis.innerG.selectAll('*').empty()) {
      timeAxis.highlight.attr('x', getLabelWidth()).attr('y', 0).attr('width', _AvailabilityUtils.SVG.ABS_MAX_DATA_WIDTH).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + 1.5 * _AvailabilityUtils.SVG.CELL_PADDING);
      _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlight');
      timeAxis.mask.attr('x', getLabelWidth()).attr('y', 0).attr('width', _AvailabilityUtils.SVG.ABS_MAX_DATA_WIDTH).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING);
      _AvailabilityUtils.SVG_STYLES.apply(timeAxis.mask, 'timeHighlightMask');
    }
    timeAxis.innerG.selectAll('text').data(function () {
      return getYearsInView(svgWidth, getTimeOffset());
    }).join('text').attr('x', function (year) {
      return getYearCenterX(year);
    }).attr('y', _AvailabilityUtils.SVG.LABEL_FONT_SIZE + 1).text(function (year) {
      return year;
    }).each(function (year, idx, labelNodes) {
      _AvailabilityUtils.SVG_STYLES.apply((0, _d3Selection.select)(labelNodes[idx]), 'timeLabel');
    });
    timeAxis.innerG.selectAll('line').data(function () {
      var lineYears = getYearsInView(svgWidth, getTimeOffset());
      return lineYears[0] === _AvailabilityUtils.TIME.START_YEAR ? lineYears.slice(1) : lineYears;
    }).join('line').attr('x1', function (year) {
      return getYearStartX(year) - _AvailabilityUtils.SVG.YEAR_PADDING / 2;
    }).attr('y1', 0).attr('x2', function (year) {
      return getYearStartX(year) - _AvailabilityUtils.SVG.YEAR_PADDING / 2;
    }).attr('y2', svgHeight).each(function (year, idx, lineNodes) {
      _AvailabilityUtils.SVG_STYLES.apply((0, _d3Selection.select)(lineNodes[idx]), 'timeDivider');
    });
  };

  /**
     SVG: Row Data
  */
  var dataG = dragContentG.append('g').attr('class', 'dataG');
  var dataMasksG = svg.append('g').attr('class', 'dataMasksG');
  var redrawData = function redrawData() {
    // Click/drag masks
    dataMasksG.selectAll('rect').data(rowKeys).join('rect').attr('x', getLabelWidth()).attr('y', function (d, idx) {
      return _AvailabilityUtils.SVG.CELL_PADDING / 2 + (rowCount - idx) * (_AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING);
    }).attr('width', svgWidth - getLabelWidth()).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', 'transparent').style('cursor', selectionEnabled && setSitesValue ? 'pointer' : 'grab').style('outline', 'none').on('mouseover', function (event, d) {
      return rowHighlightHover(d);
    }).on('focus', function (event, d) {
      return rowHighlightHover(d);
    }).on('mouseout', function (event, d) {
      return rowHighlightReset(true);
    }).on('blur', function (event, d) {
      return rowHighlightReset(true);
    }).on('click', selectionEnabled && setSitesValue ? function (event, d) {
      _AvailabilityUtils.SVG_STYLES.touchRipple((0, _d3Selection.select)(event.currentTarget), 15);
      setTimeout(function () {
        return toggleSelection(d);
      }, 15);
    } : function (event, d) {});
    // Cells
    dataG.selectAll('g').data(rowKeys).join('g').attr('transform', getRowTranslation).each(function (rowKey, rowIdx, gNodes) {
      var rowData = data.rows[rowKey];
      var getCellAttr = function getCellAttr(month, attr) {
        var status = rowData[month];
        return !_AvailabilitySvgComponents.CELL_ATTRS[status] ? _AvailabilitySvgComponents.CELL_ATTRS['not available'][attr] || null : _AvailabilitySvgComponents.CELL_ATTRS[status][attr] || null;
      };
      (0, _d3Selection.select)(gNodes[rowIdx]).selectAll('rect').data(function () {
        return getYearMonthsInView(svgWidth, getTimeOffset());
      }).join('rect').attr('cursor', 'pointer').attr('x', function (month) {
        return getYearMonthStartX(month) + (getCellAttr(month, 'nudge') || 0);
      }).attr('y', function (month) {
        return getCellAttr(month, 'nudge') || 0;
      }).attr('rx', "".concat(_AvailabilityUtils.SVG.CELL_RX, "px")).attr('width', function (month) {
        return getCellAttr(month, 'width');
      }).attr('height', function (month) {
        return getCellAttr(month, 'height');
      }).attr('fill', function (month) {
        return getCellAttr(month, 'fill');
      }).attr('stroke', function (month) {
        return getCellAttr(month, 'stroke');
      }).attr('stroke-width', function (month) {
        return getCellAttr(month, 'strokeWidth');
      });
    });
  };

  /**
     SVG: Date Range Handles
  */
  var dateRangeHandlesG = selectionEnabled ? dragG.append('g').attr('class', 'dateRangeHandlesG') : null;
  var redrawDateRangeHandles = function redrawDateRangeHandles() {
    if (!selectionEnabled) {
      return;
    }
    var isHighlighted = function isHighlighted(d) {
      return dateRangeHoverKey === d || draggingDateRange[d].dragging;
    };
    var yBounds = Object.keys(viewSelections).reduce(function (acc, key) {
      var y = getRowY(rowKeys.indexOf(key));
      var low = y - _AvailabilityUtils.SVG.CELL_PADDING / 2;
      var high = y + _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING / 2;
      return [acc[0] === null || acc[0] > low ? low : acc[0], acc[1] === null || acc[1] < high ? high : acc[1]];
    }, [null, null]);
    dateRangeHandlesG.selectAll('rect').data([0, 1]).join('rect').attr('class', function (d) {
      return "dateRange".concat(d === 0 ? 'Start' : 'End', "HandleRect");
    }).attr('x', function (d) {
      var useWidth = isHighlighted(d) ? _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH + 2 : _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH;
      var gutterX = getYearMonthGutterX(dateRange.value[d], d === 0 ? 'left' : 'right');
      if (d === 0 && dateRange.value[d] === _AvailabilityUtils.TIME.MIN_YEAR_MONTH) {
        return gutterX;
      }
      if (d === 1 && dateRange.value[d] === _AvailabilityUtils.TIME.MAX_YEAR_MONTH) {
        return gutterX - useWidth;
      }
      return gutterX - useWidth / 2;
    }).attr('width', function (d) {
      return isHighlighted(d) ? _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH + 2 : _AvailabilityUtils.SVG.DATE_RANGE_HANDLE_WIDTH;
    }).attr('y', function (d) {
      if (isHighlighted(d)) {
        return getRowY(rowKeys.length - 1) - _AvailabilityUtils.SVG.CELL_PADDING / 2;
      }
      return yBounds[0];
    }).attr('height', function (d) {
      if (isHighlighted(d)) {
        return svgHeight - getRowY(rowKeys.length - 1) + _AvailabilityUtils.SVG.CELL_PADDING / 2 - 0.5;
      }
      return yBounds[1] - yBounds[0];
    }).attr('fill', function (d) {
      return isHighlighted(d) ? _Theme.COLORS.LIGHT_BLUE[100] : _Theme.COLORS.LIGHT_BLUE[300];
    }).attr('stroke', _Theme.default.palette.primary.main).style('stroke-width', '1.5px').style('display', sites.value.length ? null : 'none');
  };

  /**
     SVG: Date Range Masks
  */
  var dateRangeMasksG = selectionEnabled ? svg.append('g').attr('class', 'dateRangeMasksG') : null;
  var redrawDateRangeHandleMasks = function redrawDateRangeHandleMasks() {
    if (!selectionEnabled) {
      return;
    }
    dateRangeMasksG.selectAll('rect').data([0, 1]).join('rect').attr('class', function (d) {
      return "dateRange".concat(d === 0 ? 'Start' : 'End', "MaskRect");
    }).attr('x', function (d) {
      return getYearMonthGutterX(dateRange.value[d] || _AvailabilityUtils.TIME.MIN_YEAR_MONTH, d === 0 ? 'left' : 'right') - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2 + getTimeOffset();
    }).attr('y', 0).attr('width', _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH).attr('height', svgHeight).style('cursor', 'crosshair') // 'ew-resize'
    .style('outline', 'none').attr('fill', 'red').style('opacity', 0).style('display', sites.value.length ? null : 'none');
  };

  /**
     SVG: Selections
  */
  var redrawSelections = function redrawSelections() {
    if (!selectionEnabled) {
      return;
    }

    // Row and label backgrounds
    var yOffset = _AvailabilityUtils.SVG.CELL_PADDING / 2;
    var yMultiplier = _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING;
    var y = function y(d) {
      return yOffset + (rowCount - rowKeys.indexOf(d)) * yMultiplier;
    };
    var fill = function fill(d) {
      return viewSelections[d] === 'full' ? _Theme.default.palette.primary.main : _Theme.COLORS.LIGHT_BLUE[200];
    };
    var startX = getYearMonthGutterX(dateRange.value[0], 'left');
    var endX = getYearMonthGutterX(dateRange.value[1], 'right');
    if (startX > endX) {
      var swapX = startX;
      startX = endX;
      endX = swapX;
    }
    rowSelectionsG.selectAll('rect').data(Object.keys(viewSelections)).join('rect').attr('x', startX).attr('y', y).attr('width', endX - startX).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', fill);
    if (setSitesValue) {
      labelSelectionsG.selectAll('rect').data(Object.keys(viewSelections)).join('rect').attr('x', 0).attr('y', y).attr('width', getLabelWidth()).attr('height', _AvailabilityUtils.SVG.CELL_HEIGHT + _AvailabilityUtils.SVG.CELL_PADDING).attr('fill', fill);
    }

    // Date range handles
    redrawDateRangeHandles();
  };

  /**
     Redraw functions
  */
  var redraw = function redraw() {
    redrawTimeAxis();
    redrawData();
    if (selectionEnabled) {
      redrawSelections();
    }
  };
  // const debouncedRedraw = debounce(redraw, 150);

  /**
     Invoke initial redraws
  */
  redraw();
  redrawDateRangeHandleMasks();

  /**
     Setup Interactions
  */
  var timeHighlightReset = (0, _lodash.debounce)(function () {
    if (draggingCells) {
      return;
    }
    dataMasksG.selectAll('rect').style('cursor', selectionEnabled ? 'pointer' : 'grab');
    timeAxis.mask.style('cursor', 'grab');
    _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlight');
  }, 100);
  var timeHighlightHover = function timeHighlightHover() {
    if (draggingCells) {
      return;
    }
    timeHighlightReset.cancel();
    _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlightHover');
  };
  var cellDragTime = null;
  var dragCells = (0, _d3Drag.drag)().on('start', function (event, d) {
    draggingCells = true;
    rowHighlightReset(false);
    dataMasksG.selectAll('rect').style('cursor', 'grabbing');
    timeAxis.mask.style('cursor', 'grabbing');
    _AvailabilityUtils.SVG_STYLES.apply(timeAxis.highlight, 'timeHighlightDrag');
    cellDragTime = new Date().getTime();
  }).on('drag', function (event, d) {
    setTimeOffset(getTimeOffset() + event.dx);
    redrawData();
    redrawDateRangeHandleMasks();
  }).on('end', function (event, d) {
    draggingCells = false;
    rowHighlightHover(rowHoverKey);
    timeHighlightReset();
    redraw();
    redrawDateRangeHandleMasks();
    // If the drag was less than 1/10 of a second long assume it's a sloppy click.
    // Perform a select action if selection is enabled to keep the end user happy. =)
    cellDragTime = new Date().getTime() - cellDragTime;
    if (selectionEnabled && setSitesValue && cellDragTime < 100) {
      _AvailabilityUtils.SVG_STYLES.touchRipple(dataMasksG.selectAll('rect').filter(function (filterD) {
        return filterD === rowHoverKey;
      }), 15);
      setTimeout(function () {
        return toggleSelection(rowHoverKey);
      }, 15);
    }
  });
  dragCells(timeAxis.mask);
  dragCells(dataMasksG.selectAll('rect'));
  timeAxis.mask.on('wheel', function (event, d) {
    event.preventDefault();
    var step = (_AvailabilityUtils.SVG.CELL_WIDTH + _AvailabilityUtils.SVG.CELL_PADDING) * 3;
    var delta = (event.wheelDelta > 0 ? -1 : 1) * step;
    setTimeOffset(getTimeOffset() + delta);
    redraw();
    redrawDateRangeHandleMasks();
  }).on('mouseover', function (event, d) {
    return timeHighlightHover();
  }).on('focus', function (event, d) {
    return timeHighlightHover();
  }).on('mouseout', function (event, d) {
    return timeHighlightReset();
  }).on('blur', function (event, d) {
    return timeHighlightReset();
  });
  if (selectionEnabled) {
    var dateRangeHandleReset = (0, _lodash.debounce)(function () {
      dateRangeHoverKey = null;
      redrawDateRangeHandles();
    }, 100);
    var dateRangeHandleHover = function dateRangeHandleHover(key) {
      dateRangeHoverKey = key;
      redrawDateRangeHandles();
    };

    // Function to flip date range handles, masks, and values if a drag event puts start after end
    // Shift values by one month on each side if flipping as start looks ahead and end looks back
    var flipDateRangeSelectionIfNeeded = function flipDateRangeSelectionIfNeeded() {
      if (dateRange.value[1] < dateRange.value[0]) {
        dateRange.value = [_AvailabilityUtils.TIME.getNextMonth(dateRange.value[1]), _AvailabilityUtils.TIME.getPreviousMonth(dateRange.value[0])];
        // Only if the handles are atop each other will this still be true after the last flip.
        // In this case hard set to the same value (so one month selected).
        if (dateRange.value[1] < dateRange.value[0]) {
          dateRange.value[0] = dateRange.value[1]; // eslint-disable-line prefer-destructuring
        }
      }
    };

    // Interactions for Date Range START Handle
    var dragDateRangeStartMask = dateRangeMasksG.select('.dateRangeStartMaskRect');
    dragDateRangeStartMask.on('mouseover', function (event, d) {
      return dateRangeHandleHover(0);
    }).on('focus', function (event, d) {
      return dateRangeHandleHover(0);
    }).on('mouseout', function (event, d) {
      return dateRangeHandleReset();
    }).on('blur', function (event, d) {
      return dateRangeHandleReset();
    });
    var dragDateRangeStart = (0, _d3Drag.drag)().on('start', function (event, d) {
      draggingDateRange[0].dragging = true;
      draggingDateRange[0].centerDragX = parseFloat(dragDateRangeStartMask.attr('x'), 10) + _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2;
    }).on('drag', function (event, d) {
      draggingDateRange[0].centerDragX += event.dx;
      var centerDragX = draggingDateRange[0].centerDragX;
      dragDateRangeStartMask.attr('x', centerDragX - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2);
      var nextYearMonth = getXOffsetYearMonth(centerDragX, getTimeOffset(), 'right');
      var nextYearMonthStartX = getYearMonthGutterX(nextYearMonth, 'left');
      var currentYearMonthStartX = getYearMonthGutterX(dateRange.value[0], 'left');
      var insideClipCenterDragX = draggingDateRange[0].centerDragX - getTimeOffset();
      var distanceToNext = Math.abs(insideClipCenterDragX - nextYearMonthStartX);
      var distanceToCurrent = Math.abs(insideClipCenterDragX - currentYearMonthStartX);
      if (nextYearMonth !== dateRange.value[0] && distanceToNext < distanceToCurrent) {
        dateRange.value[0] = nextYearMonth;
        redrawSelections();
      }
    }).on('end', function (event, d) {
      draggingDateRange[0].dragging = false;
      draggingDateRange[0].centerDragX = 0;
      // Recenter mask as it is likely off a few pixels due to snap-to-gutter behavior
      var maskX = getYearMonthGutterX(dateRange.value[0], 'left') + _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2 + getTimeOffset();
      dateRangeMasksG.select('.dateRangeStartMaskRect').attr('x', maskX);
      flipDateRangeSelectionIfNeeded();
      setDateRangeValue(_toConsumableArray(dateRange.value));
      redrawSelections();
    });
    dragDateRangeStart(dateRangeMasksG.select('.dateRangeStartMaskRect'));

    // Interactions for Date Range END Handle
    var dragDateRangeEndMask = dateRangeMasksG.select('.dateRangeEndMaskRect');
    dragDateRangeEndMask.on('mouseover', function (event, d) {
      return dateRangeHandleHover(1);
    }).on('focus', function (event, d) {
      return dateRangeHandleHover(1);
    }).on('mouseout', function (event, d) {
      return dateRangeHandleReset();
    }).on('blur', function (event, d) {
      return dateRangeHandleReset();
    });
    var dragDateRangeEnd = (0, _d3Drag.drag)().on('start', function (event, d) {
      draggingDateRange[1].dragging = true;
      draggingDateRange[1].centerDragX = parseFloat(dragDateRangeEndMask.attr('x'), 10) + _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2;
    }).on('drag', function (event, d) {
      draggingDateRange[1].centerDragX += event.dx;
      var centerDragX = draggingDateRange[1].centerDragX;
      dragDateRangeEndMask.attr('x', centerDragX - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2);
      var nextYearMonth = getXOffsetYearMonth(centerDragX, getTimeOffset(), 'left');
      var nextYearMonthEndX = getYearMonthGutterX(nextYearMonth, 'right');
      var currentYearMonthEndX = getYearMonthGutterX(dateRange.value[1], 'right');
      var insideClipCenterDragX = draggingDateRange[1].centerDragX - getTimeOffset();
      var distanceToNext = Math.abs(insideClipCenterDragX - nextYearMonthEndX);
      var distanceToCurrent = Math.abs(insideClipCenterDragX - currentYearMonthEndX);
      if (nextYearMonth !== dateRange.value[1] && distanceToNext < distanceToCurrent) {
        dateRange.value[1] = nextYearMonth;
        redrawSelections();
      }
    }).on('end', function (event, d) {
      draggingDateRange[1].dragging = false;
      draggingDateRange[1].centerDragX = 0;
      // Recenter mask as it is likely off a few pixels due to snap-to-gutter behavior
      var maskX = getYearMonthGutterX(dateRange.value[1], 'right') - _AvailabilityUtils.SVG.DATE_RANGE_MASK_WIDTH / 2 + getTimeOffset();
      dateRangeMasksG.select('.dateRangeEndMaskRect').attr('x', maskX);
      flipDateRangeSelectionIfNeeded();
      setDateRangeValue(_toConsumableArray(dateRange.value));
      redrawSelections();
    });
    dragDateRangeEnd(dateRangeMasksG.select('.dateRangeEndMaskRect'));
  }
}