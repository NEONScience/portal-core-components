import React, { useReducer, useEffect } from 'react';
import PropTypes from 'prop-types';

import { map, catchError } from 'rxjs/operators';

import { makeStyles } from '@material-ui/core/styles';

import L from 'leaflet';

import 'leaflet/dist/leaflet.css';

import {
  Map,
  TileLayer,
  ScaleControl,
  Marker,
  Popup,
} from 'react-leaflet';

import NeonGraphQL from '../NeonGraphQL/NeonGraphQL';
import sitesJSON from '../../static/sites/sites.json';

import iconCoreTerrestrialSVG from './icon-core-terrestrial.svg';
import iconCoreAquaticSVG from './icon-core-aquatic.svg';
import iconCoreShadowSVG from './icon-core-shadow.svg';
import iconRelocatableTerrestrialSVG from './icon-relocatable-terrestrial.svg';
import iconRelocatableAquaticSVG from './icon-relocatable-aquatic.svg';
import iconRelocatableShadowSVG from './icon-relocatable-shadow.svg';

const iconSVGs = {
  CORE: {
    AQUATIC: iconCoreAquaticSVG,
    TERRESTRIAL: iconCoreTerrestrialSVG,
    SHADOW: iconCoreShadowSVG,
  },
  RELOCATABLE: {
    AQUATIC: iconRelocatableAquaticSVG,
    TERRESTRIAL: iconRelocatableTerrestrialSVG,
    SHADOW: iconRelocatableShadowSVG,
  },
};

const useStyles = makeStyles(() => ({
  map: {
    width: '100%',
    height: '0px', // Necessary to set a fixed aspect ratio from props (using paddingBottom)
    overflow: 'hidden',
  },
}));

// 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'

const SiteMap = (props) => {
  const {
    aspectRatio,
    center,
    zoom: initialZoom,
    sites: sitesProp,
  } = props;
  const classes = useStyles();

  const sitesArrayToKeyedObject = (sitesArray = []) => {
    if (!Array.isArray(sitesArray)) { return {}; }
    const sites = {};
    sitesArray.forEach((site) => {
      sites[site.siteCode] = {
        description: site.siteDescription || site.description,
        type: site.siteType || site.type,
        stateCode: site.stateCode,
        domainCode: site.domainCode,
        latitude: site.siteLatitude || site.latitude,
        longitude: site.siteLongitude || site.longitude,
        terrain: site.terrain || sitesJSON[site.siteCode].terrain,
      };
    });
    return sites;
  };

  /**
     Prepare sites object. Our preferred shape looks like this:
     {
       ABBY: {
         description: 'Abby Road',
         type: 'RELOCATABLE',
         stateCode: 'WA',
         domainCode: 'D16',
         terrain: 'TERRESTRIAL',
         latitude: 45.762439,
         longitude: -122.330317,
       },
       ...
     }
     We may be passed something from props that is either this or the API response
     shape, so massage whatever we have into something we can use.
  */
  let sites = {};
  let fetchSitesStatus = 'awaitingFetchCall';
  if (sitesProp) {
    if (Array.isArray(sitesProp)) {
      sites = sitesArrayToKeyedObject(sitesProp);
      fetchSitesStatus = 'fetched';
    } else if (typeof sitesProp === 'object' && Object.keys(sitesProp).length > 0) {
      sites = { ...sitesProp };
      Object.keys(sites).forEach((siteCode) => {
        if (!sites[siteCode].terrain) {
          sites[siteCode].terrain = sitesJSON[siteCode].terrain;
        }
      });
      fetchSitesStatus = 'fetched';
    }
  }

  const reducer = (state, action) => {
    switch (action.type) {
      case 'fetchSitesCalled':
        return { ...state, fetchSitesStatus: 'fetching' };
      case 'fetchSitesSucceeded':
        return { ...state, fetchSitesStatus: 'fetched', sites: action.sites };
      case 'fetchSitesFailed':
        return { ...state, fetchSitesStatus: 'error', fetchSitesError: action.error };
      case 'setZoom':
        console.log(action.zoom);
        return { ...state, zoom: action.zoom };
      default:
        return state;
    }
  };

  const initialState = {
    zoom: initialZoom,
    sites,
    fetchSitesStatus,
    fetchSitesError: null,
  };

  const [state, dispatch] = useReducer(reducer, initialState);

  const fetchAllSites$ = NeonGraphQL.getAllSites().pipe(
    map((response) => {
      console.log('FETCHED', response);
      if (response.response && response.response.data && response.response.data.sites) {
        const sitesResponse = sitesArrayToKeyedObject(response.response.data.sites);
        dispatch({ type: 'fetchSitesSucceeded', sites: sitesResponse });
      } else {
        dispatch({ type: 'fetchSitesFailed', error: 'malformed response' });
      }
    }),
    catchError((error) => {
      dispatch({ type: 'fetchSitesFailed', error });
    }),
  );

  useEffect(() => {
    if (state.fetchSitesStatus === 'awaitingFetchCall') {
      console.log('FETCHING');
      dispatch({ type: 'fetchSitesCalled' });
      fetchAllSites$.subscribe();
    }
  }, [state.fetchSitesStatus]);

  if (state.fetchSitesStatus !== 'fetched') {
    return (
      <div>
        {state.fetchSitesStatus}
      </div>
    );
  }

  const getZoomedIcon = (type, terrain) => {
    if (!iconSVGs[type] || !iconSVGs[type][terrain] || !iconSVGs[type].SHADOW) { return null; }
    const iconScale = 0.2 + (Math.floor((state.zoom - 2) / 3) / 10);
    return new L.Icon({
      iconUrl: iconSVGs[type][terrain],
      iconRetinaUrl: iconSVGs[type][terrain],
      iconSize: [100, 100].map(x => x * iconScale),
      iconAnchor: [50, 100].map(x => x * iconScale),
      shadowUrl: iconSVGs[type].SHADOW,
      shadowSize: [156, 93].map(x => x * iconScale),
      shadowAnchor: [50, 95].map(x => x * iconScale),
      popupAnchor: [0, -100].map(x => x * iconScale),
    });
  };

  const renderSiteMarkers = () => {
    const zoomedIcons = {
      CORE: {
        AQUATIC: getZoomedIcon('CORE', 'AQUATIC'),
        TERRESTRIAL: getZoomedIcon('CORE', 'TERRESTRIAL'),
      },
      RELOCATABLE: {
        AQUATIC: getZoomedIcon('RELOCATABLE', 'AQUATIC'),
        TERRESTRIAL: getZoomedIcon('RELOCATABLE', 'TERRESTRIAL'),
      },
    };
    return Object.keys(state.sites).map((siteCode) => {
      const site = state.sites[siteCode];
      if (!zoomedIcons[site.type] || !zoomedIcons[site.type][site.terrain]
          || !site.latitude || !site.longitude) {
        return null;
      }
      return (
        <Marker
          key={siteCode}
          position={[site.latitude, site.longitude]}
          icon={zoomedIcons[site.type][site.terrain]}
        >
          <Popup>{siteCode}</Popup>
        </Marker>
      );
    });
  };

  return (
    <Map
      className={classes.map}
      style={{ paddingBottom: `${aspectRatio * 100}%` }}
      center={center}
      zoom={state.zoom}
      maxZoom={17}
      minZoom={2}
      onZoomEnd={(event) => { dispatch({ type: 'setZoom', zoom: event.target.getZoom() }); }}
    >
      <TileLayer url="https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png" />
      {renderSiteMarkers()}
      <ScaleControl imperial metric updateWhenIdle />
    </Map>
  );
};

SiteMap.propTypes = {
  aspectRatio: PropTypes.number,
  center: PropTypes.arrayOf(PropTypes.number),
  zoom: PropTypes.number,
  sites: PropTypes.oneOf([
    PropTypes.arrayOf(
      PropTypes.shape({
        siteCode: PropTypes.string.isRequired,
        siteDescription: PropTypes.string.isRequired,
        siteLatitude: PropTypes.number.isRequired,
        siteLongitude: PropTypes.number.isRequired,
        siteType: PropTypes.string,
        domainCode: PropTypes.string,
        stateCode: PropTypes.string,
        terrain: PropTypes.string,
      }),
    ),
    PropTypes.objectOf(
      PropTypes.shape({
        description: PropTypes.string.isRequired,
        latitude: PropTypes.number.isRequired,
        longitude: PropTypes.number.isRequired,
        type: PropTypes.string.isRequired,
        terrain: PropTypes.string.isRequired,
        domainCode: PropTypes.string.isRequired,
        stateCode: PropTypes.string.isRequired,
      }),
    ),
  ]),
};

SiteMap.defaultProps = {
  aspectRatio: 0.75,
  center: [44.967, -103.767], // [47.229, -112.382],
  zoom: 3,
  sites: null,
};

export default SiteMap;
